/**********************************************************************
 *  This file is part of exact-real.
 *
 *        Copyright (C) 2020 Julian Rüth
 *
 *  exact-real is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  exact-real is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with exact-real. If not, see <https://www.gnu.org/licenses/>.
 *********************************************************************/

#include <benchmark/benchmark.h>
#include <e-antic/renfxx.h>

#include <algorithm>
#include <memory>

#include "../exact-real/arb.hpp"
#include "../exact-real/element.hpp"
#include "../exact-real/integer_ring.hpp"
#include "../exact-real/module.hpp"
#include "../exact-real/number_field.hpp"
#include "../exact-real/rational_field.hpp"
#include "../exact-real/real_number.hpp"

namespace exactreal::test {

template <typename Ring>
class ElementBenchmark : public benchmark::Fixture {
  typename Ring::ElementClass coefficient() {
    return rand() % 1024 + 1;
  }

  Element<Ring> monomial(std::vector<long> degrees, const std::vector<std::shared_ptr<const RealNumber>>& gens) {
    Element<Ring> x = Module<Ring>::make({RealNumber::rational(1)})->gen(0);

    for (int i = 0; i < degrees.size(); i++)
      while (degrees[i]--)
        x *= *gens[i];

    return x;
  }

  Element<Ring> element(std::vector<long> degrees, const std::vector<std::shared_ptr<const RealNumber>>& gens) {
    const auto module = Module<Ring>::make({RealNumber::rational(1)});

    auto x = coefficient() * monomial(degrees, gens);

    if (!std::any_of(begin(degrees), end(degrees), [](const long d) { return d; }))
      return x;

    while (true) {
      const size_t i = rand() % degrees.size();
      if (degrees[i]) {
        degrees[i]--;
        return x + element(degrees, gens);
      }
    }
  }

  /// Return a pair of elements (lhs, rhs) in a Module generated by 1 and
  /// vars=state.range(0) random reals r_0, r_1, ….
  /// The elements are sums of c·f where c is a random coefficient and f is a
  /// product of powers of the random reals where each exponent is bound by the
  /// remaining state.range entries.
  auto elements(benchmark::State& state) {
    const long vars = state.range(0);

    std::vector<std::shared_ptr<const RealNumber>> gens;
    gens.push_back(RealNumber::rational(1));
    for (int i = 0; i < vars; i++)
      gens.push_back(RealNumber::random());

    std::vector<long> lhs_degrees, rhs_degrees;
    for (int i = 0; i < vars; i++) {
      lhs_degrees.push_back(state.range(1 + i));
      rhs_degrees.push_back(state.range(1 + vars + i));
    }

    return std::tuple{element(lhs_degrees, gens), element(rhs_degrees, gens)};
  }

 public:
  void addition(benchmark::State& state) {
    const auto [lhs, rhs] = elements(state);

    for (auto _ : state) {
      benchmark::DoNotOptimize(lhs + rhs);
    }
  }

  void multiplication(benchmark::State& state) {
    const auto [lhs, rhs] = elements(state);

    for (auto _ : state) {
      benchmark::DoNotOptimize(lhs * rhs);
    }
  }

  void square(benchmark::State& state) {
    const auto [element, __] = elements(state);

    for (auto _ : state) {
      benchmark::DoNotOptimize(element * element);
    }
  }

  void truediv(benchmark::State& state) {
    const auto [lhs, rhs] = elements(state);

    const auto dividend = lhs * rhs;
    const auto divisor = rhs;

    for (auto _ : state) {
      const auto quotient = dividend.truediv(divisor);
      assert(quotient);
    }
  }

  void floordiv(benchmark::State& state) {
    const auto [lhs, rhs] = elements(state);

    const auto dividend = lhs * rhs;
    const auto divisor = rhs;

    for (auto _ : state) {
      benchmark::DoNotOptimize(dividend.floordiv(divisor));
    }
  }

  void arb(benchmark::State& state) {
    const auto [element, __] = elements(state);
    (void)__;

    for (auto _ : state) {
      benchmark::DoNotOptimize(element.arb(exactreal::ARB_PRECISION_FAST));
    }
  }

  void nonzero(benchmark::State& state) {
    const auto [element, __] = elements(state);
    (void)__;

    for (auto _ : state) {
      benchmark::DoNotOptimize(static_cast<bool>(element));
    }
  }

  static void BenchmarkedDegrees(benchmark::internal::Benchmark* b) {
    // elements in zero variables, i.e., base ring elements
    b->Args({0});
    // elements in one variable, x^1 + … (lower degree summands,) and x^1 + …
    b->Args({1, 1, 1});
    // elements in two variables, x^1 + …, and y^1 + …
    b->Args({2, 1, 0, 0, 1});
    // elements x^3*y^4 + …, and x^1*y^2 + …
    b->Args({2, 3, 4, 1, 2});
  }
};

BENCHMARK_TEMPLATE_DEFINE_F(ElementBenchmark, addition_Z, IntegerRing)
(benchmark::State& state) { addition(state); }
BENCHMARK_REGISTER_F(ElementBenchmark, addition_Z)->Apply(ElementBenchmark<IntegerRing>::BenchmarkedDegrees);

BENCHMARK_TEMPLATE_DEFINE_F(ElementBenchmark, addition_Q, RationalField)
(benchmark::State& state) { addition(state); }
BENCHMARK_REGISTER_F(ElementBenchmark, addition_Q)->Apply(ElementBenchmark<RationalField>::BenchmarkedDegrees);

BENCHMARK_TEMPLATE_DEFINE_F(ElementBenchmark, addition_K, NumberField)
(benchmark::State& state) { addition(state); }
BENCHMARK_REGISTER_F(ElementBenchmark, addition_K)->Apply(ElementBenchmark<NumberField>::BenchmarkedDegrees);

BENCHMARK_TEMPLATE_DEFINE_F(ElementBenchmark, multiplication_Z, IntegerRing)
(benchmark::State& state) { multiplication(state); }
BENCHMARK_REGISTER_F(ElementBenchmark, multiplication_Z)->Apply(ElementBenchmark<IntegerRing>::BenchmarkedDegrees);

BENCHMARK_TEMPLATE_DEFINE_F(ElementBenchmark, multiplication_Q, RationalField)
(benchmark::State& state) { multiplication(state); }
BENCHMARK_REGISTER_F(ElementBenchmark, multiplication_Q)->Apply(ElementBenchmark<RationalField>::BenchmarkedDegrees);

BENCHMARK_TEMPLATE_DEFINE_F(ElementBenchmark, multiplication_K, NumberField)
(benchmark::State& state) { multiplication(state); }
BENCHMARK_REGISTER_F(ElementBenchmark, multiplication_K)->Apply(ElementBenchmark<NumberField>::BenchmarkedDegrees);

BENCHMARK_TEMPLATE_DEFINE_F(ElementBenchmark, square_Z, IntegerRing)
(benchmark::State& state) { square(state); }
BENCHMARK_REGISTER_F(ElementBenchmark, square_Z)->Apply(ElementBenchmark<IntegerRing>::BenchmarkedDegrees);

BENCHMARK_TEMPLATE_DEFINE_F(ElementBenchmark, square_Q, RationalField)
(benchmark::State& state) { square(state); }
BENCHMARK_REGISTER_F(ElementBenchmark, square_Q)->Apply(ElementBenchmark<RationalField>::BenchmarkedDegrees);

BENCHMARK_TEMPLATE_DEFINE_F(ElementBenchmark, square_K, NumberField)
(benchmark::State& state) { square(state); }
BENCHMARK_REGISTER_F(ElementBenchmark, square_K)->Apply(ElementBenchmark<NumberField>::BenchmarkedDegrees);

BENCHMARK_TEMPLATE_DEFINE_F(ElementBenchmark, truediv_Z, IntegerRing)
(benchmark::State& state) { truediv(state); }
BENCHMARK_REGISTER_F(ElementBenchmark, truediv_Z)->Apply(ElementBenchmark<IntegerRing>::BenchmarkedDegrees);

BENCHMARK_TEMPLATE_DEFINE_F(ElementBenchmark, truediv_Q, RationalField)
(benchmark::State& state) { truediv(state); }
BENCHMARK_REGISTER_F(ElementBenchmark, truediv_Q)->Apply(ElementBenchmark<RationalField>::BenchmarkedDegrees);

BENCHMARK_TEMPLATE_DEFINE_F(ElementBenchmark, truediv_K, NumberField)
(benchmark::State& state) { truediv(state); }
BENCHMARK_REGISTER_F(ElementBenchmark, truediv_K)->Apply(ElementBenchmark<NumberField>::BenchmarkedDegrees);

BENCHMARK_TEMPLATE_DEFINE_F(ElementBenchmark, floordiv_Z, IntegerRing)
(benchmark::State& state) { floordiv(state); }
BENCHMARK_REGISTER_F(ElementBenchmark, floordiv_Z)->Apply(ElementBenchmark<IntegerRing>::BenchmarkedDegrees);

BENCHMARK_TEMPLATE_DEFINE_F(ElementBenchmark, floordiv_Q, RationalField)
(benchmark::State& state) { floordiv(state); }
BENCHMARK_REGISTER_F(ElementBenchmark, floordiv_Q)->Apply(ElementBenchmark<RationalField>::BenchmarkedDegrees);

BENCHMARK_TEMPLATE_DEFINE_F(ElementBenchmark, floordiv_K, NumberField)
(benchmark::State& state) { floordiv(state); }
BENCHMARK_REGISTER_F(ElementBenchmark, floordiv_K)->Apply(ElementBenchmark<NumberField>::BenchmarkedDegrees);

BENCHMARK_TEMPLATE_DEFINE_F(ElementBenchmark, arb_Z, IntegerRing)
(benchmark::State& state) { arb(state); }
BENCHMARK_REGISTER_F(ElementBenchmark, arb_Z)->Apply(ElementBenchmark<IntegerRing>::BenchmarkedDegrees);

BENCHMARK_TEMPLATE_DEFINE_F(ElementBenchmark, arb_Q, RationalField)
(benchmark::State& state) { arb(state); }
BENCHMARK_REGISTER_F(ElementBenchmark, arb_Q)->Apply(ElementBenchmark<RationalField>::BenchmarkedDegrees);

BENCHMARK_TEMPLATE_DEFINE_F(ElementBenchmark, arb_K, NumberField)
(benchmark::State& state) { arb(state); }
BENCHMARK_REGISTER_F(ElementBenchmark, arb_K)->Apply(ElementBenchmark<NumberField>::BenchmarkedDegrees);

}  // namespace exactreal::test
